### golang

1. new 和 make 的区别

2. map的实现原理，为什么是随机遍历

3. 内存分配和垃圾回收

4. goroutine MPG 模型

5. channel CSP 模型

6. interface 方法的集合和一种类型

7. slice 和 array 

8. reflect 反射

9. 基础数据类型和零值

10. 闭包

11. grpc 

12. protobuf

13. 单元测试

14. 调优

### redis

1. 基础数据类型

2. AOF和RDS

3. 缓存策略

4. 淘汰策略（LRU算法）

5. 分布式锁

6. 同步机制

7. redis 集群

8. 性能优化

9. 内存碎片

10. 内存模型

### mysql

1. 慢查询优化

2. 共享锁和排他锁

3. 索引(B+Tree)

4. 分库分表分区

5. 主从复制原理

6. 读写分离

7. 事务的隔离级别

8. innodb和myisam

9. 表结构设计

10. 表碎片

### 数据结构和算法

1. 数组，字符串，链表，树，排序和搜索，动态规划，设计问题。

2. 时间复杂度和空间复杂度

### 计算机网络

1. TCP和UDP的区别

2. 如何用UDP实现TCP

3. http1.0 http1.1 http2 https

4. 一次完整的HTTP请求（当你输入一个网址，实际会发生什么?）

5. 三次握手 四次挥手

### 工作经历

1. 支付功能（抢购问题实现，订单过期时间）

2. 短信/消息功能（消息集中发送问题）

3. 微信公众号，小程序等api（api调用）

4. 打卡系统（并发问题，重复打卡和缓存的使用）

5. redis共享session

6. 分析问题解决问题的能力

7. 学习能力

### 其他

1. 设计模式(单例模式)

2. hash一致性

3. 微服务

4. 分布式（事务，数据一致性）

5. 简历（star法则）

6. 缓冲区溢出

7. unix

8. ngnix

### 答案

1. new和make的区别

> new：内置函数 new 分配空间。传递给 new 函数的是一个类型，不是一个值。返回值是指向这个新分配的零值的指针。

> make：内置函数 make 分配并且初始化 一个 slice, 或者 map 或者 chan 对象。 并且只能是这三种对象。 和 new 一样，第一个参数是 类型，
不是一个值。 但是make 的返回值就是这个类型（即使一个引用类型），而不是指针。 具体的返回值，依赖具体传入的类型。


golang 反射reflection
反射可大大提高程序的灵活性，使得interface{}有更大的发挥余地
反射使用TypeOf和ValueOf函数从接口中获取目标对象信息
反射会将匿名字段作为独立字段(匿名字段本质)
想要利用反射修改对象状态，前提是interface.data是settable，即pointer-interface
通过反射可以“动态”调用方法

一个Goroutine会以一个很小的栈启动（可能是2KB或4KB），当遇到深度递归导致当前栈空间不足时，Goroutine会根据需要动态地伸缩栈的大小
（主流实现中栈的最大值可达到1GB）。因为启动的代价很小，所以我们可以轻易地启动成千上万个Goroutine。
Go的运行时还包含了其自己的调度器，这个调度器使用了一些技术手段，可以在n
个操作系统线程上多工调度m个Goroutine。Go调度器的工作和内核的调度是相似
的，但是这个调度器只关注单独的Go程序中的Goroutine。Goroutine采用的是半抢
占式的协作调度，只有在当前Goroutine发生阻塞时才会导致调度；同时发生在用户
态，调度器会根据具体函数只保存必要的寄存器，切换的代价要比系统线程低得
多。运行时有一个 runtime.GOMAXPROCS 变量，用于控制当前运行正常非阻塞
Goroutine的系统线程数目。
