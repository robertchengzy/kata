## 4 Schema与数据类型优化
### 4.2 MySQL schema 设计中的缺陷

#### 太多的列
> MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓存格式拷贝数据，然后再服务器层将缓冲内容解码成各个列。从行缓冲中奖编码过的列转换成行数据结构的操作代价是非常高的。

#### 太多的关联
> MySQL限制了每个关联操作最多只能有61张表。单个查询最好在12个表以内做关联。

#### 全能的枚举
> 注意防止过度使用枚举(ENUM)。在MySQL中，当需要在枚举列表中增加一个新的值时就啊要做一次ALTER TABLE操作。

#### 变相的枚举
> 枚举(ENUM)列允许在列中存储一组定义值中的单个值，集合(SET)列则允许在列中存储一组定义值中的一个或多个和值。

#### 非此发明的NULL
> 确实需要表示未知值时也不要害怕使用NULL。MySQL会在索引中存储NULL值。

### 4.3 范式和反范式

#### 4.3.1 范式的优点和缺点

> 更新操作快
> 修改更少的数据
> 执行操作快
> 很少有多余的数据，检索列表时更少需要DISTINCT或者GROUP BY语句。
> 缺点是通常需要关联。

#### 4.3.2 反范式的优点和缺点

> 很好的避免关联
> 当数据比内存大时候，比关联快得多，因为这样避免了随机I/O。
> 单独的表可以使用更有效的策略索引。

#### 4.3.3 混用范式化和反范式化

> 最常见的反范式化数据的方式是复制和缓存，在不同的表中存储相同的特定的列。

### 4.4 缓存表和汇总表

> 缓存表表示存储那些可以比较简单地从schema其他表获取（但是每次获取的速度比较慢）数据的表。
> 汇总表保存的是使用GROUP BY语句聚合数据的表。

#### 4.4.1 物化视图

#### 4.4.2 计数器表
> 网站点击次数，预先在计数器表中增加100行数据，然后选择一个随笔的槽进行更新。
> 每隔一段时间开始一个新的计数器。
> 如果希望减少表的行数，以避免表变得太大，可以写一个周期执行任务，合并所有结果到0号槽。

### 4.5 加快 ALTER TABLE 操作的速度
> MySQL执行大部分修改表的结构操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表。
> 所有的MODIFY COLUMN操作都将导致表重建，ALTER COLUMN直接修改.frm文件而不涉及表数据。

#### 4.5.1 只修改.frm文件
> 下面这些操作有可能不需要重建表的：
> * 移除一个列的AUTO_INCREMENT属性
> * 增加、移除，或更改ENUM和SET常量。如果移除的是已经有行数据用到其值的常量，查询将会返回一个空字符串。

> 基本技术是为想要的表结构创建一个新的.frm文件，然后用它替换掉已经存在的那种表的.frm文件。
> 1. 创建一张有相同结构的空表，并进行所需要的修改。
> 2. 执行FLUSH TABLES WITH READ LOCK。这将会关闭所有正在所用的表，并且禁止任何表被打开。
> 3. 交换.frm文件
> 4. 执行UNLOCK TABLES 来释放第2步的锁。
