## 4 Schema与数据类型优化
### 4.1选择优化的数据类型
> ##### 更小的通常更好
> 一般情况下，应该尽量使用可以正确存储数据的最小数据类型。

> ##### 简单就好
> 简单数据类型的操作通常需要更少的CPU周期。

> ##### 尽量避免NULL
> 最好指定列为NOT NULL，除非真的需要存储NULL值。NULL列使得索引、索引统计和值比较都更复杂。可为NULL的列会使用更多的存储空间，在MySQL里也需要特殊处理。当可为NULL的列被索引时，每个索引记录需要一个额外的字节。如果计划在列上建索引，就应该避免设计成可为NULL列。InnoDB使用单独的位存储NULL值，所以对于稀疏数据有很好的空间效率。

#### 4.1.1 整数类型
> * 如果存储整数，类型有TINYINT，SMALLINT，MEDIUINT，INT，BIGINT。分别使用8，16，24，32，64位存储空间。存储范围位-2（N-1）到2（N-1）-1。
> * 整数类型有可选的UNSIGNED属性，表示不允许空置值。MySQL可以为整数类型制定宽度，它不会限制值的合法范围，只是规定显示字符的个数。

#### 4.1.2 实数类型
> * FLOAT和DOUBLE类型支持使用标准的浮点运算进行近似计算。
> * DECIMAL类型用于存储精确的小数。MySQL服务器自身实现了DECIMAL的高精度计算。
> * 浮点和DECIMAL类型都可以指定精度。DECIMAL可以指定前后允许的最大位数，影响列的空间消耗。
> * DECIMAL允许最多65个数字。在计算中DECIMAL会转换为DOUBLE类型。
> * 精度定义时非标准的，建议只指定数据类型，不指定精度。
> * FLOAT-4字节，DOUBLE-8字节。存储同样范围的值时，DECIMAL使用更少的空间。
> * DOUBLE作为内部浮点计算的类型。
> * 数据量比较大时，可以考虑吧使用BIGINT代替DECIMAL。

#### 4.1.3 字符串类型
##### VARCHAR 和 CHAR 类型
> VARCHAR
> * 存储变长字符串。比定长节省空间。如果创建表时ROW_FORMAT=FIXED，每一行都会使用定长。
> * 使用1或2个额外字节记录字符串长度。如果列的最大长度小于或等于255字节，则使用1个字节表示，否则使用2个字节。
> * UPDATE时可能使行边长，导致需要做额外的工作。
> * 使用场景：字符串列的最大长度比平均长度大很多；列的更新少，所以碎片不是问题；使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储。
>
> * InnoDB把过长的VARCHAR存储为BLOB。

> CHAR
> * 是定长的：根据定义的字符串长度分配足够的空间。当存储CHAR值时，会删除所有的末尾空格。会根据需要采用空格进行填充以方便比较。
> * 适合存储很短的字符串，或者所有值都接近一个长度。如：MD5值。

> * 类似的类型：BINARY和VARBINARY。二进制字符串存储的是字节码，采用\0（零字节）填充，检索时也不会去掉填充值。二进制比较比字符简单也就更快。
> * 更长的列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部的值。使用内存临时表进行排序或操作时会特别糟糕；利用磁盘临时表进行排序时也同样糟糕。
> 所以更好的策略是只分配真正需要的空间。

##### BLOB 和 TEXT 类型
> 为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符串方式存储。
> * 字符类型是TINYTEXT,SMALLTEXT,TEXT,MEDIUMTEXT,LONGTEXT;二进制类型是TINYBLOB,SMALLBLOB,BLOB,MEDIUMBLOB,LONGBLON。BLOB=SMALLBLOB,TEXT=SMALLTEXT.
> * 当作一个独立的对象处理，当值太大时，InnoDB会使用专门的“外部”存储区域进行存储，每个值需要1-4字节存储一个指针，在外部存储区域存储实际的值。
> * TEXT类型有字符集和排序规则，BLOB没有。只对列的最前max_sort_length字节而不是整个字符串排序。（order by substring(column, length)）

#### 使用枚举（ENUM）代替字符串类型
> * 枚举列可以把一些不重复的字符串存储在一个预定义的集合。存储枚举时非常紧凑，会根据列表值的数量压缩到一个或者两个子捷众。在内部会将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存“数字-字符串”映射关系的“查找表”。
> * 排序按照内部存储的整数，而不是定义的字符串。（FIELD()函数显式地指定排序顺序，但会导致MySQL无法利用索引消除排序）
> * 枚举最不好的地方是，字符串列表是固定的，添加或删除字符串必须使用ALTER TABLE。

#### 4.1.4 日期和时间类型
> DATETIME
> * 范围：1001-9999，精度为秒。它把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关。使用8个字节的存储空间。MySQL以一种可排序，无歧义的格式显示DATETIME。

> TIMESTAMP
> * 范围：1970-01-01（格林尼治标准时间）以来的秒数到2038年。，和UNIX时间戳相同。使用4个字节的存储空间。FROM_UNIXTIME()和UNIX_TIMESTAMP()，日和Unix时间戳互相转换。
> * 如果插入时没有指定一个TIMESTAMP的值，MySQL则设置这个列的值为当前时间（版本不同会变动，SHOW CREATE TABLE检查输出）。显示的值依赖时区。
> * TIMESTAMP列默认为NOT NULL。
> * 存储更小粒度的日期和时间值，可以使用BIGINT类型存储微妙级别的时间戳，或者使用DOUBLE存储秒之后的小数部分，

#### 4.1.5 位数据类型
> BIT
> * 字符串类型，避免使用此类型。

> SET
> * 如果需要保存很多true/false值时使用，在MySQL内部是以一些列打包的位的集合来表示的。FIELD_IN_SET()和FIELD()查询函数。
> * 缺点：改变列的定义的代价较高（需要ALTER TABLE）；无法在SET列上通过索引查找。
> * 替代SET方式：用一个整数包装一系列的位。

#### 4.1.6 选择标识符（identifier）
> * 确保在所有的关联表中都使用同样的类型。满足需求范围和预留未来增长空间的前提下，应选择最小的数据类型。
> ###### 整数类型
> 最好的选择，很快并且可以使用AUTO_INCREMENT。
> ###### ENUM 和 SET 类型
> 枚举字段为主键的查找表（术语表）
> ###### 字符串类型
> * 消耗空间，避免使用，比数字类型慢。
> * 对于完全“随机”的字符串，例如MD5(),SHA1()或者UUID()产生的字符串，生成的新值会任意分布在很大的空间内，导致INSERT以及一些SELECT语句变得很慢。插入值会随机地写到索引的不同位置，使得INSERT语句更慢。逻辑上相邻的行会分布在磁盘和内存的不同地方，使得SELECT语句更慢。随机值导致缓存对所有类型的查询语句效果都很差，因为会使得缓存赖以工作的访问局部性原理失效。
> * 如果存储UUID值，则应该移除“-”符号；更好的做法是，用UNHEX()函数转换UUID值为16字节的数字，并且存储在一个BINARY(16)列中。检索时可以通过HEX()函数来格式化为十六进制格式。分布不均匀，但有一定的顺序。

#### 4.1.7 特殊数据类型
> IPv4地址，用无符号整数存储IP地址。MySQL提供INET_ATON()和INET_NTOA()函数在字符串和无符号整数之间转换。
