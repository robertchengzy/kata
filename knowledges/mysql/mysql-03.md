## 5. 创建高性能的索引

> 索引也叫键，是存储引擎用于快速找到记录的一种数据结构。

#### 5.1 索引基础
> * MySQL先在索引中找到对应的位置，然后根据匹配的索引记录找到对应的数据行。
> * 索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也非常重要，因为MySQL只能高效地使用索引的最左前缀列。

> #### 5.1.1 索引的类型
> ##### B-Tree索引（InnoDB即B+Tree，每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。）
> * B-Tree意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。
> * 叶子节点的指针指向的是被索引的数据，而不是其他的节点页。
> * 适合查找范围数据。
> * 索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。
> * B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。全值匹配，匹配最左前缀，匹配列前缀，匹配范围值，精确匹配某一列并范围匹配另外一列，只访问索引的查询。
> * 索引可用于查询中的ORDER BY操作（按顺序查找）

> 限制：
> * 如果不是按照索引的最左列开始查找，则无法使用索引。
> * 不能跳过索引中的列。
> * 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。

> ##### 哈希索引
> InnoDB特殊功能：自适应哈希索引，当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引之上在创建一个哈希索引。

> ##### 空间数据索引（R-Tree）

> ##### 全文索引

#### 5.2 索引的优点

> 1. 索引大大减少了服务器需要扫描的数据量
> 2. 索引可以帮助服务器避免排序和临时表。
> 3. 索引可以将随机I/O变为顺序I/O。

#### 5.3 高性能的索引策略

> ##### 5.3.1 独立的列
> 始终将索引列单独放在比较符号的一侧。

> ##### 5.3.2 前缀索引和索引选择性
> * 索引选择性是指，不重复的索引。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。
> * 一般情况下某个列前缀的选择性也是足够高的，足以满足查询性能。对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。
> * 为了决定前缀的合适长度，需要找到最常见的值的列表，然后和最常见的前缀列表进行比较。
> * 计算完整列的选择性，并使前缀的选择性接近于完整列的选择性。（SELECT(DISTINCT city)/COUNT(\*), LEFT(city, 3)）
> * 缺点：MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。

> ##### 5.3.3 多列索引
> 查询能够同时使用这个两个单列索引进行扫描，并将结果进行合并。这种算法有三个变种：OR条件的联合（union），AND条件的相交（intersection）,组合前两种情况的联合及相交。

> 索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建得很糟糕：
> * 当出现服务器对多个索引做相交操作时（通常有多个AND条件），通常以为着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。
> * 当服务器需要对多个索引做联合操作时（通常有多个OR条件），通常需要耗费大量CPU和内存资源在算法的缓存、排序和合并操作上。
> * 更重要的是，优化器不会把这些计算到“查询成本”中，优化器只关心随机页面读取。
> * 如果在EXPLAIN中看到有索引合并，应检查一下查询和表的结构，看是不是已经是最优的。也可以通过参数optimizer_swith来关闭索引合并功能。也可以使用IGNORE INDEX提示让优化器忽略掉某些索引。

> ##### 5.3.4 选择合适的索引列顺序
> 依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。
> 在一个多列B+Tree中，索引列的顺序首先按照最左列进行排序，其次是第二列。
> 经验法则：将索引性最高的列放到索引最前列。可能需要根据那些运行频率最高的查询来调整索引列的顺序。

> ##### 5.3.5 聚簇索引
> * 不是一种单独的索引类型，而是一种数据结构。InnoDB的聚簇索引实际上在同一个数据结构中保存了B-Tree索引和数据行。
> * 当表中有聚簇索引时，它的数据行实际上存放在索引的叶子页中。一个表只能有一个聚簇索引。
> * 叶子页包含了行的全部数据，但是节点页只包含了索引列。
> * InnoDB通过主键聚集索引。如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键作为索引。
> ###### 优点
> * 可以把相关数据保存在一起。
> * 数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中。
> * 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。
> ###### 缺点
> * 聚簇数据最大限度地提高了I/O密集型应用的性能，但如果数据都放在内存中，则访问顺序就没那么重要了，聚簇索引也没什么优势了。
> * 插入严重依赖于插入顺序。主键顺序插入最快，如不是则使用OPTIMIZE TABLE重新组织表。
> * 更新聚簇索引列代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。
> * 基于聚簇索引的表插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂问题。页分裂会导致表占用更多的磁盘空间。
> * 聚簇索引可能导致全表扫描变慢，行比较稀疏或页分裂导致数据不连续的时候。
> * 二级索引（非聚簇索引）可能比想象的大，因为耳机索引的叶子节点包含了引用行的主键。
> * 二级索引访问需要两次索引查找，而不是一次。

> 在InnoDB表中按主键顺序插入行，使用自增而不是UUID。

> ##### 5.3.6 覆盖索引
> 如果一个索引包含（或者说覆盖）所有需要查询的字段的值，则为覆盖索引。

> ##### 5.3.7 使用索引扫描来做排序
> * 通过排序操作或按索引顺序扫描生成排序结果；如果EXPLAIN出来的type列的值位“index”，则说明MySQL使用了索引扫描来做排序。
> * MySQL可以使用同一个索引既满足排序，又用于查找行。
> * 索引的列顺序和ORDER BY子句的顺序完全一致，所有列的排序方向都一样时。才可以使用索引对结果排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一张表的时，才能使用排序做索引。
> * ORDER BY 前导列为常量可以使用索引。

> ##### 5.3.8 压缩（前缀压缩）索引
> MyISAM

> ##### 5.3.9 冗余和重复索引
> 重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。

> ##### 5.3.10 未使用的索引
> 使用Percona Server或Percona Toolkit中的pt-index-usage

> ##### 5.3.11 索引和锁
> InnoDB只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。

> 总结
> 1. 单行访问是很慢的。
> 2. 按照顺序访问范围数据是很快的。
> 3. 索引覆盖查询是很快的。
